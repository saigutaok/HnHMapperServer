@using System.Net.Http.Json
@using HnHMapperServer.Core.DTOs
@using HnHMapperServer.Core.Models
@using HnHMapperServer.Web.Components.Shared
@using HnHMapperServer.Web.Models
@inject IHttpClientFactory HttpClientFactory
@inject NavigationManager Navigation
@inject IDialogService DialogService
@inject ISnackbar Snackbar
@implements IAsyncDisposable

<!-- Header with Create Timer button -->
<MudStack Row="true" Justify="Justify.SpaceBetween" AlignItems="AlignItems.Center" Class="mb-3">
    <MudText Typo="Typo.h6">
        <MudIcon Icon="@Icons.Material.Filled.Timer" Size="Size.Small" Class="mr-1" />
        Events & Timers
    </MudText>
    <MudButton StartIcon="@Icons.Material.Filled.Add"
               Size="Size.Small"
               Color="Color.Primary"
               Variant="Variant.Filled"
               OnClick="CreateTimer">
        New Timer
    </MudButton>
</MudStack>

<!-- Filter tabs -->
<MudTabs Elevation="0" Rounded="true" ApplyEffectsToContainer="true" Class="mb-3" @bind-ActivePanelIndex="_activeTabIndex">
    <MudTabPanel Text="Active" Icon="@Icons.Material.Filled.Schedule" BadgeData="@_activeCount" BadgeColor="Color.Primary">
        @if (!Timers.Any())
        {
            <MudAlert Severity="Severity.Info" Dense="true" Class="mt-3">
                No active timers. Create a timer to track resources or events!
            </MudAlert>
        }
        else
        {
            <!-- Grouped timers with expandable panels -->
            <MudExpansionPanels MultiExpansion="true" Elevation="0" Dense="true">
                @foreach (var group in GetTimerGroups())
                {
                    <MudExpansionPanel Class="@GetGroupPanelClass(group.Color)"
                                       IsInitiallyExpanded="@group.IsExpanded"
                                       Dense="true">
                        <TitleContent>
                            <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="2">
                                <MudIcon Icon="@group.Icon" Color="@group.Color" Size="Size.Medium" />
                                <MudText Typo="Typo.subtitle2">@group.Name</MudText>
                                <MudChip T="string"
                                         Size="Size.Small"
                                         Color="@group.Color"
                                         Variant="Variant.Filled"
                                         Text="@group.Count.ToString()" />
                            </MudStack>
                        </TitleContent>
                        <ChildContent>
                            <MudList T="string" Dense="true" Clickable="false">
                                @foreach (var timer in group.Timers)
                                {
                                    <MudListItem T="string" OnClick="@(() => HandleTimerClick(timer))">
                                        <MudStack Row="false" Spacing="1">
                                            <!-- Title and timer badge -->
                                            <MudStack Row="true" AlignItems="AlignItems.Center" Justify="Justify.SpaceBetween">
                                                <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="1" Style="flex: 1; min-width: 0;">
                                                    @if (!string.IsNullOrEmpty(timer.Type) && timer.Type == "Marker" && timer.MarkerId.HasValue)
                                                    {
                                                        var marker = GetMarkerData(timer.MarkerId.Value);
                                                        if (marker != null && !string.IsNullOrEmpty(marker.Image))
                                                        {
                                                            <img src="@GetMarkerIconSrc(marker.Image)"
                                                                 alt="@marker.Name"
                                                                 style="width: 20px; height: 20px; object-fit: contain;"
                                                                 onerror="this.onerror=null;this.src='/gfx/terobjs/mm/custom.png';" />
                                                        }
                                                        else
                                                        {
                                                            <MudIcon Icon="@Icons.Material.Filled.Place" Size="Size.Small" Color="Color.Primary" />
                                                        }
                                                    }
                                                    else if (!string.IsNullOrEmpty(timer.Type) && timer.Type == "CustomMarker" && timer.CustomMarkerId.HasValue)
                                                    {
                                                        var customMarker = GetCustomMarkerData(timer.CustomMarkerId.Value);
                                                        if (customMarker != null && !string.IsNullOrEmpty(customMarker.Icon))
                                                        {
                                                            <img src="@GetIconSrc(customMarker.Icon)"
                                                                 alt="@customMarker.Title"
                                                                 style="width: 20px; height: 20px; object-fit: contain;"
                                                                 onerror="this.onerror=null;this.src='/gfx/terobjs/mm/custom.png';" />
                                                        }
                                                        else
                                                        {
                                                            <MudIcon Icon="@Icons.Material.Filled.AddLocation" Size="Size.Small" Color="Color.Success" />
                                                        }
                                                    }
                                                    else
                                                    {
                                                        <MudIcon Icon="@Icons.Material.Filled.Event" Size="Size.Small" Color="Color.Tertiary" />
                                                    }
                                                    <MudText Typo="Typo.body2" Style="@GetTimerTitleStyle(timer)">
                                                        @GetTimerDisplayTitle(timer)
                                                    </MudText>
                                                </MudStack>
                                                <TimerBadge Timer="@timer" />
                                            </MudStack>

                                            <!-- Progress bar (for timers < 1 hour) -->
                                            @if (timer.TimeRemainingSeconds > 0 && timer.TimeRemainingSeconds <= 3600)
                                            {
                                                var progress = GetTimerProgress(timer);
                                                <MudProgressLinear Value="@progress"
                                                                   Color="@group.Color"
                                                                   Size="Size.Small"
                                                                   Class="mt-1" />
                                            }

                                            <!-- Description -->
                                            @if (!string.IsNullOrWhiteSpace(timer.Description))
                                            {
                                                <MudText Typo="Typo.caption" Color="Color.Tertiary">
                                                    @(timer.Description.Length > 50 ? timer.Description.Substring(0, 50) + "..." : timer.Description)
                                                </MudText>
                                            }

                                            <!-- Ready at time -->
                                            <MudText Typo="Typo.caption" Color="Color.Secondary">
                                                @FormatReadyAt(timer.ReadyAt)
                                            </MudText>

                                            <!-- Action buttons -->
                                            <MudStack Row="true" Spacing="1">
                                                <MudButton StartIcon="@Icons.Material.Filled.Edit"
                                                           Size="Size.Small"
                                                           Color="Color.Primary"
                                                           Variant="Variant.Text"
                                                           OnClick="@(() => EditTimer(timer))">
                                                    Edit
                                                </MudButton>
                                                <MudButton StartIcon="@Icons.Material.Filled.Delete"
                                                           Size="Size.Small"
                                                           Color="Color.Error"
                                                           Variant="Variant.Text"
                                                           OnClick="@(() => DeleteTimer(timer.Id))">
                                                    Delete
                                                </MudButton>
                                            </MudStack>
                                        </MudStack>
                                    </MudListItem>
                                    <MudDivider />
                                }
                            </MudList>
                        </ChildContent>
                    </MudExpansionPanel>
                }

                <!-- Empty state if no groups have timers -->
                @if (!GetTimerGroups().Any())
                {
                    <MudAlert Severity="Severity.Info" Dense="true" Class="mt-3">
                        No active timers. Create a timer to track resources or events!
                    </MudAlert>
                }
            </MudExpansionPanels>
        }
    </MudTabPanel>

    <MudTabPanel Text="History" Icon="@Icons.Material.Filled.History" BadgeData="@_historyCount" BadgeColor="Color.Secondary">
        @if (_loadingHistory)
        {
            <MudProgressLinear Indeterminate="true" Color="Color.Primary" />
        }
        else if (!_timerHistory.Any())
        {
            <MudAlert Severity="Severity.Info" Dense="true" Class="mt-3">
                No timer history yet.
            </MudAlert>
        }
        else
        {
            <MudList T="string" Dense="true" Clickable="true">
                @foreach (var history in _timerHistory)
                {
                    <MudListItem T="string" OnClick="@(() => HandleHistoryClick(history))">
                        <MudStack Row="false" Spacing="1">
                            <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="1">
                                @if (!string.IsNullOrEmpty(history.Type) && history.Type == "Marker" && history.MarkerId.HasValue)
                                {
                                    var marker = GetMarkerData(history.MarkerId.Value);
                                    if (marker != null && !string.IsNullOrEmpty(marker.Image))
                                    {
                                        <img src="@GetMarkerIconSrc(marker.Image)"
                                             alt="@marker.Name"
                                             style="width: 20px; height: 20px; object-fit: contain;"
                                             onerror="this.onerror=null;this.src='/gfx/terobjs/mm/custom.png';" />
                                    }
                                    else
                                    {
                                        <MudIcon Icon="@Icons.Material.Filled.CheckCircle" Size="Size.Small" Color="Color.Success" />
                                    }
                                }
                                else if (!string.IsNullOrEmpty(history.Type) && history.Type == "CustomMarker" && history.CustomMarkerId.HasValue)
                                {
                                    var customMarker = GetCustomMarkerData(history.CustomMarkerId.Value);
                                    if (customMarker != null && !string.IsNullOrEmpty(customMarker.Icon))
                                    {
                                        <img src="@GetIconSrc(customMarker.Icon)"
                                             alt="@customMarker.Title"
                                             style="width: 20px; height: 20px; object-fit: contain;"
                                             onerror="this.onerror=null;this.src='/gfx/terobjs/mm/custom.png';" />
                                    }
                                    else
                                    {
                                        <MudIcon Icon="@Icons.Material.Filled.CheckCircle" Size="Size.Small" Color="Color.Success" />
                                    }
                                }
                                else
                                {
                                    <MudIcon Icon="@Icons.Material.Filled.CheckCircle" Size="Size.Small" Color="Color.Success" />
                                }
                                <MudText Typo="Typo.body2">@GetHistoryDisplayTitle(history)</MudText>
                            </MudStack>
                            <MudText Typo="Typo.caption" Color="Color.Secondary" Style="padding-left: 28px;">
                                Completed @FormatHistoryTime(history.CompletedAt)
                            </MudText>
                            @if (history.Duration.HasValue)
                            {
                                <MudText Typo="Typo.caption" Color="Color.Tertiary" Style="padding-left: 28px;">
                                    Duration: @FormatDuration(history.Duration.Value)
                                </MudText>
                            }
                        </MudStack>
                    </MudListItem>
                    <MudDivider />
                }
            </MudList>
        }
    </MudTabPanel>
</MudTabs>

@code {
    // Event callbacks for marker navigation
    [Parameter] public EventCallback<MarkerModel> OnMarkerSelected { get; set; }
    [Parameter] public EventCallback<CustomMarkerViewModel> OnCustomMarkerSelected { get; set; }

    /// <summary>
    /// List of active timers passed from parent
    /// </summary>
    [Parameter] public IReadOnlyList<TimerDto> Timers { get; set; } = Array.Empty<TimerDto>();

    private List<TimerHistoryDto> _timerHistory = new();
    private bool _loadingHistory = false;
    private int _activeTabIndex = 0;
    private int _activeCount => Timers.Count;
    private int _historyCount = 0;

    // Cache marker data for icon display and navigation
    private Dictionary<int, FrontendMarker> _markerCache = new();
    private Dictionary<int, CustomMarkerViewDto> _customMarkerCache = new();

    // Periodic timer for real-time updates
    private System.Threading.Timer? _updateTimer;

    protected override async Task OnInitializedAsync()
    {
        await LoadHistory();
        await LoadMarkerData(); // Initial load of marker data for passed timers

        // Start periodic timer to update progress bars and countdown badges
        _updateTimer = new System.Threading.Timer(async _ =>
        {
            // Recalculate time remaining for all active timers
            UpdateTimerRemainingTimes();
            await InvokeAsync(StateHasChanged);
        }, null, TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(1));
    }

    protected override async Task OnParametersSetAsync()
    {
        // Reload marker data when timers change (e.g. new timer added)
        await LoadMarkerData();
        UpdateTimerRemainingTimes();
        StateHasChanged();
    }

    // LoadTimers removed - using parameter instead

    private async Task LoadHistory()
    {
        _loadingHistory = true;
        try
        {
            var httpClient = HttpClientFactory.CreateClient("API");
            _timerHistory = await httpClient.GetFromJsonAsync<List<TimerHistoryDto>>("/api/timers/history?limit=50") ?? new();
            _historyCount = _timerHistory.Count;

            // Load marker data for history items as well
            await LoadMarkerDataForHistory();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading timer history: {ex.Message}");
        }
        finally
        {
            _loadingHistory = false;
        }
    }

    /// <summary>
    /// Update TimeRemainingSeconds for all active timers (called every second)
    /// </summary>
    private void UpdateTimerRemainingTimes()
    {
        var now = DateTime.UtcNow;
        foreach (var timer in Timers)
        {
            timer.TimeRemainingSeconds = (long)(timer.ReadyAt - now).TotalSeconds;
            timer.IsReady = timer.TimeRemainingSeconds <= 0;
        }
    }

    /// <summary>
    /// Group timers by urgency level for hierarchical display
    /// </summary>
    private List<TimerGroup> GetTimerGroups()
    {
        // Filter out expired timers (auto-moved to history)
        var nonExpiredTimers = Timers.Where(t => !t.IsReady).ToList();

        var groups = new List<TimerGroup>
        {
            new TimerGroup
            {
                Name = "Urgent - Next 5 Minutes",
                Color = Color.Error,
                Icon = Icons.Material.Filled.AlarmOn,
                IsExpanded = true,
                Timers = nonExpiredTimers
                    .Where(t => t.TimeRemainingSeconds > 0 && t.TimeRemainingSeconds <= 300)
                    .OrderBy(t => t.ReadyAt)
                    .ToList()
            },
            new TimerGroup
            {
                Name = "Soon - Next Hour",
                Color = Color.Warning,
                Icon = Icons.Material.Filled.Alarm,
                IsExpanded = true,
                Timers = nonExpiredTimers
                    .Where(t => t.TimeRemainingSeconds > 300 && t.TimeRemainingSeconds <= 3600)
                    .OrderBy(t => t.ReadyAt)
                    .ToList()
            },
            new TimerGroup
            {
                Name = "Upcoming - Next 24 Hours",
                Color = Color.Info,
                Icon = Icons.Material.Filled.Schedule,
                IsExpanded = false,
                Timers = nonExpiredTimers
                    .Where(t => t.TimeRemainingSeconds > 3600 && t.TimeRemainingSeconds <= 86400)
                    .OrderBy(t => t.ReadyAt)
                    .ToList()
            },
            new TimerGroup
            {
                Name = "Later - Beyond 24 Hours",
                Color = Color.Default,
                Icon = Icons.Material.Filled.CalendarToday,
                IsExpanded = false,
                Timers = nonExpiredTimers
                    .Where(t => t.TimeRemainingSeconds > 86400)
                    .OrderBy(t => t.ReadyAt)
                    .ToList()
            }
        };

        // Only return groups that have timers
        return groups.Where(g => g.Timers.Any()).ToList();
    }

    /// <summary>
    /// Get CSS class for expansion panel based on group urgency
    /// </summary>
    private string GetGroupPanelClass(Color color)
    {
        return color switch
        {
            Color.Error => "timer-group-urgent",
            Color.Warning => "timer-group-soon",
            Color.Info => "timer-group-upcoming",
            Color.Default => "timer-group-later",
            _ => "timer-group-later"
        };
    }

    /// <summary>
    /// Calculate progress percentage for timer (0-100)
    /// </summary>
    private double GetTimerProgress(TimerDto timer)
    {
        var totalDuration = (timer.ReadyAt - timer.CreatedAt).TotalSeconds;
        var elapsed = totalDuration - timer.TimeRemainingSeconds;
        var progress = (elapsed / totalDuration) * 100.0;
        return Math.Max(0, Math.Min(100, progress));
    }

    /// <summary>
    /// Get display title for timer - shows marker name if attached to marker, otherwise custom title
    /// </summary>
    private string GetTimerDisplayTitle(TimerDto timer)
    {
        // For resource markers
        if (timer.Type == "Marker" && timer.MarkerId.HasValue)
        {
            var marker = GetMarkerData(timer.MarkerId.Value);
            if (marker != null)
            {
                return $"timer for {marker.Name}";
            }
        }
        // For custom markers
        else if (timer.Type == "CustomMarker" && timer.CustomMarkerId.HasValue)
        {
            var customMarker = GetCustomMarkerData(timer.CustomMarkerId.Value);
            if (customMarker != null)
            {
                return $"timer for {customMarker.Title}";
            }
        }

        // Fallback to timer's own title for standalone timers or if marker not found
        return timer.Title;
    }

    /// <summary>
    /// Get display title for history item - shows marker name if attached to marker, otherwise custom title
    /// </summary>
    private string GetHistoryDisplayTitle(TimerHistoryDto history)
    {
        // For resource markers
        if (history.Type == "Marker" && history.MarkerId.HasValue)
        {
            var marker = GetMarkerData(history.MarkerId.Value);
            if (marker != null)
            {
                return $"timer for {marker.Name}";
            }
        }
        // For custom markers
        else if (history.Type == "CustomMarker" && history.CustomMarkerId.HasValue)
        {
            var customMarker = GetCustomMarkerData(history.CustomMarkerId.Value);
            if (customMarker != null)
            {
                return $"timer for {customMarker.Title}";
            }
        }

        // Fallback to history's own title for standalone timers or if marker not found
        return history.Title;
    }

    private string GetTimerTitleStyle(TimerDto timer)
    {
        var fontWeight = timer.IsReady ? "600" : "400";
        return $"font-weight: {fontWeight}; flex: 1; min-width: 0; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;";
    }

    private async Task CreateTimer()
    {
        var parameters = new DialogParameters
        {
            { "ForceStandalone", true }
        };
        var options = new DialogOptions { CloseButton = true, MaxWidth = MaxWidth.Small, FullWidth = true };

        var dialog = await DialogService.ShowAsync<CreateTimerDialog>("Create Standalone Timer", parameters, options);
        var result = await dialog.Result;

        if (!result.Canceled)
        {
            // Parent component will receive SSE update and refresh the list
            Snackbar.Add("Timer created successfully", Severity.Success);
        }
    }

    private async Task EditTimer(TimerDto timer)
    {
        var parameters = new DialogParameters
        {
            { "Timer", timer }
        };
        var options = new DialogOptions { CloseButton = true, MaxWidth = MaxWidth.Small, FullWidth = true };

        var dialog = await DialogService.ShowAsync<CreateTimerDialog>("Edit Timer", parameters, options);
        var result = await dialog.Result;

        if (!result.Canceled)
        {
            // Parent component will receive SSE update and refresh the list
            Snackbar.Add("Timer updated successfully", Severity.Success);
        }
    }

    private async Task CompleteTimer(int timerId)
    {
        try
        {
            var httpClient = HttpClientFactory.CreateClient("API");
            await httpClient.PostAsync($"/api/timers/{timerId}/complete", null);
            // Parent component will receive SSE update and refresh the list
            await LoadHistory();
            Snackbar.Add("Timer completed", Severity.Success);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error completing timer: {ex.Message}");
            Snackbar.Add("Failed to complete timer", Severity.Error);
        }
    }

    private async Task DeleteTimer(int timerId)
    {
        var confirm = await DialogService.ShowMessageBox(
            "Delete Timer",
            "Are you sure you want to delete this timer?",
            yesText: "Delete", cancelText: "Cancel");

        if (confirm == true)
        {
            try
            {
                var httpClient = HttpClientFactory.CreateClient("API");
                await httpClient.DeleteAsync($"/api/timers/{timerId}");
                // Parent component will receive SSE update and refresh the list
                Snackbar.Add("Timer deleted", Severity.Success);
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error deleting timer: {ex.Message}");
                Snackbar.Add("Failed to delete timer", Severity.Error);
            }
        }
    }

    private async Task LoadMarkerData()
    {
        try
        {
            var httpClient = HttpClientFactory.CreateClient("API");

            // Get all marker IDs from timers
            var markerIds = Timers
                .Where(t => t.Type == "Marker" && t.MarkerId.HasValue)
                .Select(t => t.MarkerId!.Value)
                .Distinct()
                .ToList();

            // Get all custom marker IDs from timers
            var customMarkerIds = Timers
                .Where(t => t.Type == "CustomMarker" && t.CustomMarkerId.HasValue)
                .Select(t => t.CustomMarkerId!.Value)
                .Distinct()
                .ToList();

            // Fetch resource markers if any
            if (markerIds.Any())
            {
                var allMarkers = await httpClient.GetFromJsonAsync<List<FrontendMarker>>("/map/api/v1/markers") ?? new();
                foreach (var marker in allMarkers.Where(m => markerIds.Contains(m.Id)))
                {
                    _markerCache[marker.Id] = marker;
                }
            }

            // Fetch custom markers if any
            // Note: Custom markers require mapId, so we need to fetch them individually or get all
            if (customMarkerIds.Any())
            {
                // Get unique map IDs from timers with custom markers
                var mapIds = new HashSet<int>();

                // We need to find which maps these custom markers are on
                // For now, we'll try to fetch individual custom markers by ID
                foreach (var customMarkerId in customMarkerIds)
                {
                    try
                    {
                        var customMarker = await httpClient.GetFromJsonAsync<CustomMarkerViewDto>($"/map/api/v1/custom-markers/{customMarkerId}");
                        if (customMarker != null)
                        {
                            _customMarkerCache[customMarker.Id] = customMarker;
                        }
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine($"Error loading custom marker {customMarkerId}: {ex.Message}");
                    }
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading marker data: {ex.Message}");
        }
    }

    private async Task LoadMarkerDataForHistory()
    {
        try
        {
            var httpClient = HttpClientFactory.CreateClient("API");

            // Get all marker IDs from history
            var markerIds = _timerHistory
                .Where(h => h.Type == "Marker" && h.MarkerId.HasValue)
                .Select(h => h.MarkerId!.Value)
                .Distinct()
                .ToList();

            // Get all custom marker IDs from history
            var customMarkerIds = _timerHistory
                .Where(h => h.Type == "CustomMarker" && h.CustomMarkerId.HasValue)
                .Select(h => h.CustomMarkerId!.Value)
                .Distinct()
                .ToList();

            // Fetch resource markers if any (add to existing cache)
            if (markerIds.Any())
            {
                var allMarkers = await httpClient.GetFromJsonAsync<List<FrontendMarker>>("/map/api/v1/markers") ?? new();
                foreach (var marker in allMarkers.Where(m => markerIds.Contains(m.Id)))
                {
                    if (!_markerCache.ContainsKey(marker.Id))
                    {
                        _markerCache[marker.Id] = marker;
                    }
                }
            }

            // Fetch custom markers if any (add to existing cache)
            if (customMarkerIds.Any())
            {
                foreach (var customMarkerId in customMarkerIds)
                {
                    // Skip if already cached
                    if (_customMarkerCache.ContainsKey(customMarkerId))
                        continue;

                    try
                    {
                        var customMarker = await httpClient.GetFromJsonAsync<CustomMarkerViewDto>($"/map/api/v1/custom-markers/{customMarkerId}");
                        if (customMarker != null)
                        {
                            _customMarkerCache[customMarker.Id] = customMarker;
                        }
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine($"Error loading custom marker {customMarkerId}: {ex.Message}");
                    }
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading marker data for history: {ex.Message}");
        }
    }

    private FrontendMarker? GetMarkerData(int markerId)
    {
        _markerCache.TryGetValue(markerId, out var marker);
        return marker;
    }

    private CustomMarkerViewDto? GetCustomMarkerData(int customMarkerId)
    {
        _customMarkerCache.TryGetValue(customMarkerId, out var customMarker);
        return customMarker;
    }

    private async Task HandleTimerClick(TimerDto timer)
    {
        // Navigate to marker if timer is associated with one
        if (timer.Type == "Marker" && timer.MarkerId.HasValue)
        {
            var frontendMarker = GetMarkerData(timer.MarkerId.Value);
            if (frontendMarker != null)
            {
                // Convert FrontendMarker to MarkerModel
                var markerModel = new MarkerModel
                {
                    Id = frontendMarker.Id,
                    Name = frontendMarker.Name,
                    Map = frontendMarker.Map,
                    Position = new HnHMapperServer.Web.Models.Position
                    {
                        X = frontendMarker.Position.X,
                        Y = frontendMarker.Position.Y
                    },
                    Image = frontendMarker.Image,
                    Hidden = frontendMarker.Hidden,
                    MinReady = frontendMarker.MinReady,
                    MaxReady = frontendMarker.MaxReady,
                    Ready = frontendMarker.Ready
                };

                // Invoke the callback to select the marker
                await OnMarkerSelected.InvokeAsync(markerModel);
            }
        }
        else if (timer.Type == "CustomMarker" && timer.CustomMarkerId.HasValue)
        {
            var customMarkerDto = GetCustomMarkerData(timer.CustomMarkerId.Value);
            if (customMarkerDto != null)
            {
                // Convert CustomMarkerViewDto to CustomMarkerViewModel
                var customMarkerViewModel = new CustomMarkerViewModel
                {
                    Id = customMarkerDto.Id,
                    MapId = customMarkerDto.MapId,
                    CoordX = customMarkerDto.CoordX,
                    CoordY = customMarkerDto.CoordY,
                    X = customMarkerDto.X,
                    Y = customMarkerDto.Y,
                    Title = customMarkerDto.Title,
                    Description = customMarkerDto.Description,
                    Icon = customMarkerDto.Icon,
                    CreatedBy = customMarkerDto.CreatedBy,
                    PlacedAt = customMarkerDto.PlacedAt,
                    UpdatedAt = customMarkerDto.UpdatedAt,
                    Hidden = customMarkerDto.Hidden,
                    CanEdit = customMarkerDto.CanEdit
                };

                // Invoke the callback to select the custom marker
                await OnCustomMarkerSelected.InvokeAsync(customMarkerViewModel);
            }
        }
    }

    private async Task HandleHistoryClick(TimerHistoryDto history)
    {
        // Navigate to marker if history item is associated with one
        if (history.Type == "Marker" && history.MarkerId.HasValue)
        {
            var frontendMarker = GetMarkerData(history.MarkerId.Value);
            if (frontendMarker != null)
            {
                // Convert FrontendMarker to MarkerModel
                var markerModel = new MarkerModel
                {
                    Id = frontendMarker.Id,
                    Name = frontendMarker.Name,
                    Map = frontendMarker.Map,
                    Position = new HnHMapperServer.Web.Models.Position
                    {
                        X = frontendMarker.Position.X,
                        Y = frontendMarker.Position.Y
                    },
                    Image = frontendMarker.Image,
                    Hidden = frontendMarker.Hidden,
                    MinReady = frontendMarker.MinReady,
                    MaxReady = frontendMarker.MaxReady,
                    Ready = frontendMarker.Ready
                };

                // Invoke the callback to select the marker
                await OnMarkerSelected.InvokeAsync(markerModel);
            }
        }
        else if (history.Type == "CustomMarker" && history.CustomMarkerId.HasValue)
        {
            var customMarkerDto = GetCustomMarkerData(history.CustomMarkerId.Value);
            if (customMarkerDto != null)
            {
                // Convert CustomMarkerViewDto to CustomMarkerViewModel
                var customMarkerViewModel = new CustomMarkerViewModel
                {
                    Id = customMarkerDto.Id,
                    MapId = customMarkerDto.MapId,
                    CoordX = customMarkerDto.CoordX,
                    CoordY = customMarkerDto.CoordY,
                    X = customMarkerDto.X,
                    Y = customMarkerDto.Y,
                    Title = customMarkerDto.Title,
                    Description = customMarkerDto.Description,
                    Icon = customMarkerDto.Icon,
                    CreatedBy = customMarkerDto.CreatedBy,
                    PlacedAt = customMarkerDto.PlacedAt,
                    UpdatedAt = customMarkerDto.UpdatedAt,
                    Hidden = customMarkerDto.Hidden,
                    CanEdit = customMarkerDto.CanEdit
                };

                // Invoke the callback to select the custom marker
                await OnCustomMarkerSelected.InvokeAsync(customMarkerViewModel);
            }
        }
    }

    private string FormatReadyAt(DateTime readyAt)
    {
        var local = readyAt.ToLocalTime();
        var now = DateTime.Now;

        if (local.Date == now.Date)
            return $"Today at {local:HH:mm}";
        if (local.Date == now.AddDays(1).Date)
            return $"Tomorrow at {local:HH:mm}";
        if (local.Date == now.AddDays(-1).Date)
            return $"Yesterday at {local:HH:mm}";

        return local.ToString("MMM d 'at' HH:mm");
    }

    private string FormatHistoryTime(DateTime completedAt)
    {
        var elapsed = DateTime.UtcNow - completedAt;

        if (elapsed.TotalMinutes < 1)
            return "just now";
        if (elapsed.TotalMinutes < 60)
            return $"{(int)elapsed.TotalMinutes}m ago";
        if (elapsed.TotalHours < 24)
            return $"{(int)elapsed.TotalHours}h ago";
        if (elapsed.TotalDays < 7)
            return $"{(int)elapsed.TotalDays}d ago";

        return completedAt.ToLocalTime().ToString("MMM d");
    }

    private string FormatDuration(int seconds)
    {
        var duration = TimeSpan.FromSeconds(seconds);

        if (duration.TotalDays >= 1)
            return $"{(int)duration.TotalDays}d {duration.Hours}h";
        if (duration.TotalHours >= 1)
            return $"{(int)duration.TotalHours}h {duration.Minutes}m";

        return $"{duration.Minutes}m";
    }

    /// <summary>
    /// Build icon source path with fallback and leading slash handling
    /// </summary>
    private static string GetIconSrc(string icon)
    {
        if (string.IsNullOrWhiteSpace(icon))
        {
            return "/gfx/terobjs/mm/custom.png";
        }

        var trimmed = icon.Trim();
        return trimmed.StartsWith('/') ? trimmed : $"/{trimmed}";
    }

    /// <summary>
    /// Build resource marker icon source path with .png extension
    /// </summary>
    private static string GetMarkerIconSrc(string imagePath)
    {
        if (string.IsNullOrWhiteSpace(imagePath))
        {
            return "/gfx/terobjs/mm/custom.png";
        }

        var trimmed = imagePath.Trim();
        var withSlash = trimmed.StartsWith('/') ? trimmed : $"/{trimmed}";
        return withSlash.EndsWith(".png") ? withSlash : $"{withSlash}.png";
    }

    public async ValueTask DisposeAsync()
    {
        // Stop the update timer
        if (_updateTimer != null)
        {
            await _updateTimer.DisposeAsync();
            _updateTimer = null;
        }
    }

    /// <summary>
    /// Helper class for grouping timers by urgency level
    /// </summary>
    private class TimerGroup
    {
        public string Name { get; set; } = "";
        public Color Color { get; set; }
        public string Icon { get; set; } = "";
        public bool IsExpanded { get; set; }
        public List<TimerDto> Timers { get; set; } = new();
        public int Count => Timers.Count;
    }
}
