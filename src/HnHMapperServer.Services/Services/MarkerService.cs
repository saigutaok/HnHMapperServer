using HnHMapperServer.Core.Interfaces;
using HnHMapperServer.Core.Models;
using HnHMapperServer.Services.Interfaces;
using Microsoft.Extensions.Logging;

namespace HnHMapperServer.Services.Services;

public class MarkerService : IMarkerService
{
    private readonly IMarkerRepository _markerRepository;
    private readonly IGridRepository _gridRepository;
    private readonly IPendingMarkerService _pendingMarkerService;
    private readonly ITenantContextAccessor _tenantContext;
    private readonly ILogger<MarkerService> _logger;

    public MarkerService(
        IMarkerRepository markerRepository,
        IGridRepository gridRepository,
        IPendingMarkerService pendingMarkerService,
        ITenantContextAccessor tenantContext,
        ILogger<MarkerService> logger)
    {
        _markerRepository = markerRepository;
        _gridRepository = gridRepository;
        _pendingMarkerService = pendingMarkerService;
        _tenantContext = tenantContext;
        _logger = logger;
    }

    public async Task<List<FrontendMarker>> GetAllFrontendMarkersAsync()
    {
        var markers = await _markerRepository.GetAllMarkersAsync();
        var frontendMarkers = new List<FrontendMarker>();

        var orphanedCount = 0;
        foreach (var marker in markers)
        {
            var grid = await _gridRepository.GetGridAsync(marker.GridId);
            if (grid == null)
            {
                orphanedCount++;
                continue;
            }

            frontendMarkers.Add(new FrontendMarker
            {
                Id = marker.Id,
                Name = marker.Name,
                Map = grid.Map,
                Position = new Position(
                    marker.Position.X + grid.Coord.X * 100,
                    marker.Position.Y + grid.Coord.Y * 100),
                Image = marker.Image,
                Hidden = marker.Hidden,
                MaxReady = marker.MaxReady,
                MinReady = marker.MinReady,
                Ready = marker.Ready
            });
        }

        if (orphanedCount > 0)
        {
            _logger.LogWarning("Skipped {OrphanedCount} orphaned markers (missing grids) out of {TotalCount} total",
                orphanedCount, markers.Count);
        }

        return frontendMarkers;
    }

    public async Task UpdateMarkerReadyTimeAsync(string gridId, int x, int y, long maxReady, long minReady)
    {
        var key = $"{gridId}_{x}_{y}";
        var marker = await _markerRepository.GetMarkerByKeyAsync(key);

        if (marker == null)
            return;

        if (marker.MaxReady == -1 || marker.MinReady == -1)
        {
            marker.MaxReady = maxReady;
            marker.MinReady = minReady;
        }
        else
        {
            // Narrow the time window
            if (maxReady < marker.MaxReady)
                marker.MaxReady = maxReady;

            if (minReady > marker.MinReady)
                marker.MinReady = minReady;
        }

        await _markerRepository.SaveMarkerAsync(marker, key);
    }

    public async Task UpdateMarkerAsync(string gridId, int x, int y, string name, string image, bool ready)
    {
        // Check if grid exists first
        var grid = await _gridRepository.GetGridAsync(gridId);
        if (grid == null)
        {
            // Grid doesn't exist yet - queue marker in memory for later
            var tenantId = _tenantContext.GetRequiredTenantId();
            _pendingMarkerService.QueueMarker(tenantId, gridId, x, y, name, image);
            _logger.LogDebug("Marker {Name} queued as pending (grid {GridId} not yet uploaded)", name, gridId);
            return;
        }

        var key = $"{gridId}_{x}_{y}";
        var existing = await _markerRepository.GetMarkerByKeyAsync(key);

        if (existing == null)
        {
            // Create new marker - database will auto-generate ID
            var marker = new Marker
            {
                Id = 0, // Will be auto-generated by database
                Name = name,
                GridId = gridId,
                Position = new Position(x, y),
                Image = image,
                Ready = false,
                MaxReady = -1,
                MinReady = -1
            };

            await _markerRepository.SaveMarkerAsync(marker, key);
            _logger.LogDebug("Created new marker {Name} at {Key} with ID={MarkerId}", name, key, marker.Id);
        }
        else
        {
            // Update ready status
            if (ready && !existing.Ready)
            {
                existing.Ready = true;
                existing.MaxReady = -1;
                existing.MinReady = -1;
                await _markerRepository.SaveMarkerAsync(existing, key);
                _logger.LogInformation("Marker {Name} is now ready", existing.Name);
            }
            else if (!ready && existing.Ready)
            {
                existing.Ready = false;
                existing.MaxReady = -1;
                existing.MinReady = -1;
                await _markerRepository.SaveMarkerAsync(existing, key);
                _logger.LogInformation("Marker {Name} is no longer ready", existing.Name);
            }
        }
    }

    public async Task BulkUploadMarkersAsync(List<(string GridId, int X, int Y, string Name, string Image)> markers)
    {
        if (markers.Count == 0)
            return;

        // Build marker batch for efficient bulk insert
        var markerBatch = new List<(Marker marker, string key)>(markers.Count);

        foreach (var (gridId, x, y, name, image) in markers)
        {
            var key = $"{gridId}_{x}_{y}";
            var img = string.IsNullOrEmpty(image) ? "gfx/terobjs/mm/custom" : image;

            var marker = new Marker
            {
                Id = 0,
                Name = name,
                GridId = gridId,
                Position = new Position(x, y),
                Image = img,
                Ready = false,
                MaxReady = -1,
                MinReady = -1
            };

            markerBatch.Add((marker, key));
        }

        // Single batch insert (filters out existing keys internally)
        var inserted = await _markerRepository.SaveMarkersBatchAsync(markerBatch);

        if (inserted > 0)
        {
            _logger.LogInformation("Bulk inserted {Count} markers (skipped {Skipped} existing)",
                inserted, markers.Count - inserted);
        }
    }

    public async Task DeleteMarkersAsync(List<(string GridId, int X, int Y)> markers)
    {
        foreach (var (gridId, x, y) in markers)
        {
            var key = $"{gridId}_{x}_{y}";
            await _markerRepository.DeleteMarkerAsync(key);
            _logger.LogInformation("Deleted marker at {Key}", key);
        }
    }

    public async Task HideMarkerAsync(int markerId)
    {
        var marker = await _markerRepository.GetMarkerAsync(markerId);
        if (marker == null)
            return;

        marker.Hidden = true;
        var key = $"{marker.GridId}_{marker.Position.X}_{marker.Position.Y}";
        await _markerRepository.SaveMarkerAsync(marker, key);
    }

    public async Task DeleteMarkerByIdAsync(int markerId)
    {
        var marker = await _markerRepository.GetMarkerAsync(markerId);
        if (marker == null)
            return;

        var key = $"{marker.GridId}_{marker.Position.X}_{marker.Position.Y}";
        await _markerRepository.DeleteMarkerAsync(key);
        _logger.LogInformation("Deleted marker {Id} with key {Key}", markerId, key);
    }

    public async Task UpdateReadinessOnMarkersAsync(string tenantId)
    {
        // OPTIMIZED: Use tenant-specific query instead of loading all markers
        // This avoids loading markers from other tenants in background services
        var markers = await _markerRepository.GetMarkersByTenantAsync(tenantId);
        var now = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds();

        // Collect all markers that need to be updated
        var updates = new List<(int markerId, bool ready, long maxReady, long minReady)>();
        var updatedNames = new List<string>();

        foreach (var marker in markers)
        {
            if (!marker.Ready && marker.MaxReady != -1 && marker.MaxReady < now)
            {
                updates.Add((marker.Id, true, -1, -1));
                updatedNames.Add(marker.Name);
            }
        }

        if (updates.Count > 0)
        {
            // OPTIMIZED: Single batch update instead of N individual saves
            var updated = await _markerRepository.BatchUpdateReadinessAsync(updates, tenantId);

            foreach (var name in updatedNames)
            {
                _logger.LogInformation("Marker {Name} (Tenant: {TenantId}) is now ready to be harvested!",
                    name, tenantId);
            }
        }
    }

    public async Task<int> CleanupOrphanedMarkersAsync(string tenantId)
    {
        var orphanedMarkers = await _markerRepository.GetOrphanedMarkersAsync(tenantId);

        if (orphanedMarkers.Count == 0)
            return 0;

        // Log details about orphaned markers before deleting
        var markerTypes = orphanedMarkers
            .GroupBy(m => m.Name)
            .Select(g => $"{g.Key}: {g.Count()}")
            .ToList();

        _logger.LogWarning(
            "Found {Count} orphaned markers for tenant {TenantId}. Types: {Types}",
            orphanedMarkers.Count, tenantId, string.Join(", ", markerTypes));

        // Delete orphaned markers
        var markerIds = orphanedMarkers.Select(m => m.Id).ToList();
        var deleted = await _markerRepository.DeleteMarkersByIdsAsync(markerIds, tenantId);

        _logger.LogInformation(
            "Deleted {Count} orphaned markers for tenant {TenantId}",
            deleted, tenantId);

        return deleted;
    }
}
