using HnHMapperServer.Core.Interfaces;
using HnHMapperServer.Core.Models;
using HnHMapperServer.Services.Interfaces;
using Microsoft.Extensions.Logging;

namespace HnHMapperServer.Services.Services;

public class MarkerService : IMarkerService
{
    private readonly IMarkerRepository _markerRepository;
    private readonly IGridRepository _gridRepository;
    private readonly ILogger<MarkerService> _logger;

    public MarkerService(
        IMarkerRepository markerRepository,
        IGridRepository gridRepository,
        ILogger<MarkerService> logger)
    {
        _markerRepository = markerRepository;
        _gridRepository = gridRepository;
        _logger = logger;
    }

    public async Task<List<FrontendMarker>> GetAllFrontendMarkersAsync()
    {
        var markers = await _markerRepository.GetAllMarkersAsync();
        var frontendMarkers = new List<FrontendMarker>();

        foreach (var marker in markers)
        {
            var grid = await _gridRepository.GetGridAsync(marker.GridId);
            if (grid == null)
                continue;

            frontendMarkers.Add(new FrontendMarker
            {
                Id = marker.Id,
                Name = marker.Name,
                Map = grid.Map,
                Position = new Position(
                    marker.Position.X + grid.Coord.X * 100,
                    marker.Position.Y + grid.Coord.Y * 100),
                Image = marker.Image,
                Hidden = marker.Hidden,
                MaxReady = marker.MaxReady,
                MinReady = marker.MinReady,
                Ready = marker.Ready
            });
        }

        return frontendMarkers;
    }

    public async Task UpdateMarkerReadyTimeAsync(string gridId, int x, int y, long maxReady, long minReady)
    {
        var key = $"{gridId}_{x}_{y}";
        var marker = await _markerRepository.GetMarkerByKeyAsync(key);

        if (marker == null)
            return;

        if (marker.MaxReady == -1 || marker.MinReady == -1)
        {
            marker.MaxReady = maxReady;
            marker.MinReady = minReady;
        }
        else
        {
            // Narrow the time window
            if (maxReady < marker.MaxReady)
                marker.MaxReady = maxReady;

            if (minReady > marker.MinReady)
                marker.MinReady = minReady;
        }

        await _markerRepository.SaveMarkerAsync(marker, key);
    }

    public async Task UpdateMarkerAsync(string gridId, int x, int y, string name, string image, bool ready)
    {
        var key = $"{gridId}_{x}_{y}";
        var existing = await _markerRepository.GetMarkerByKeyAsync(key);

        if (existing == null)
        {
            // Create new marker - database will auto-generate ID
            var marker = new Marker
            {
                Id = 0, // Will be auto-generated by database
                Name = name,
                GridId = gridId,
                Position = new Position(x, y),
                Image = image,
                Ready = false,
                MaxReady = -1,
                MinReady = -1
            };

            await _markerRepository.SaveMarkerAsync(marker, key);
            _logger.LogDebug("Created new marker {Name} at {Key} with ID={MarkerId}", name, key, marker.Id);
        }
        else
        {
            // Update ready status
            if (ready && !existing.Ready)
            {
                existing.Ready = true;
                existing.MaxReady = -1;
                existing.MinReady = -1;
                await _markerRepository.SaveMarkerAsync(existing, key);
                _logger.LogInformation("Marker {Name} is now ready", existing.Name);
            }
            else if (!ready && existing.Ready)
            {
                existing.Ready = false;
                existing.MaxReady = -1;
                existing.MinReady = -1;
                await _markerRepository.SaveMarkerAsync(existing, key);
                _logger.LogInformation("Marker {Name} is no longer ready", existing.Name);
            }
        }
    }

    public async Task BulkUploadMarkersAsync(List<(string GridId, int X, int Y, string Name, string Image)> markers)
    {
        foreach (var (gridId, x, y, name, image) in markers)
        {
            var key = $"{gridId}_{x}_{y}";
            var existing = await _markerRepository.GetMarkerByKeyAsync(key);

            if (existing != null)
                continue;

            var img = string.IsNullOrEmpty(image) ? "gfx/terobjs/mm/custom" : image;

            // Create new marker - database will auto-generate ID
            var marker = new Marker
            {
                Id = 0, // Will be auto-generated by database
                Name = name,
                GridId = gridId,
                Position = new Position(x, y),
                Image = img,
                Ready = false,
                MaxReady = -1,
                MinReady = -1
            };

            await _markerRepository.SaveMarkerAsync(marker, key);
            _logger.LogInformation("Created marker {Name} at {Key} with ID={MarkerId}", name, key, marker.Id);
        }
    }

    public async Task DeleteMarkersAsync(List<(string GridId, int X, int Y)> markers)
    {
        foreach (var (gridId, x, y) in markers)
        {
            var key = $"{gridId}_{x}_{y}";
            await _markerRepository.DeleteMarkerAsync(key);
            _logger.LogInformation("Deleted marker at {Key}", key);
        }
    }

    public async Task HideMarkerAsync(int markerId)
    {
        var marker = await _markerRepository.GetMarkerAsync(markerId);
        if (marker == null)
            return;

        marker.Hidden = true;
        var key = $"{marker.GridId}_{marker.Position.X}_{marker.Position.Y}";
        await _markerRepository.SaveMarkerAsync(marker, key);
    }

    public async Task DeleteMarkerByIdAsync(int markerId)
    {
        var marker = await _markerRepository.GetMarkerAsync(markerId);
        if (marker == null)
            return;

        var key = $"{marker.GridId}_{marker.Position.X}_{marker.Position.Y}";
        await _markerRepository.DeleteMarkerAsync(key);
        _logger.LogInformation("Deleted marker {Id} with key {Key}", markerId, key);
    }

    public async Task UpdateReadinessOnMarkersAsync(string tenantId)
    {
        // Get all markers (global query filter should apply if called from HTTP context,
        // but in background services we need to defensively filter by tenantId)
        var markers = await _markerRepository.GetAllMarkersAsync();
        var now = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds();

        // SECURITY: Filter by tenant to ensure we only process this tenant's markers
        // This is critical in background services where HttpContext is null
        var tenantMarkers = markers.Where(m => m.TenantId == tenantId).ToList();

        foreach (var marker in tenantMarkers)
        {
            if (!marker.Ready && marker.MaxReady != -1 && marker.MaxReady < now)
            {
                marker.Ready = true;
                marker.MaxReady = -1;
                marker.MinReady = -1;

                var key = $"{marker.GridId}_{marker.Position.X}_{marker.Position.Y}";
                await _markerRepository.SaveMarkerAsync(marker, key);

                _logger.LogInformation("Marker {Name} (Tenant: {TenantId}) is now ready to be harvested!",
                    marker.Name, tenantId);
            }
        }
    }
}
